Qué hacer (un poco de meta-script)
- terminar el texto de intro
--------------------------------------
- armar la app de ejemplo, ir anotando títulos de las páginas
- armar páginas
- armar script



(de acá para abajo, el script)
Speech inicial, está en el texto. 

Primero: rol de NestJS.
La pregunta de para qué sirve Nest si ya tengo Express en particular me la hice yo, con Express alcanza para levantar un servidor HTTP sobre Node. Entonces, hay algo que no es simplemente tener-un-servidor-andando que nos aporta Nest, vayamos entendiendo qué es.

Y ahí salen las ideas de
- organización (para justificar los módulos)
- simplificación (en la mayor parte del código, uno se olvida de los objetos request y response; también simplificación p.ej. del manejo de errores)
- concepto más trabajado de middleware (en lugar de un tipo solo, distintas variantes)
- conectores que simplifican el uso p.ej. de Mongoose o TypeORM
- componentes que simplifican el testing

Van los disclaimers, al que se agrega que yo no soy nada parecido a un experto de NestJS.

(saltamos a conceptos iniciales)
Repasamos nociones de controller/provider/módulo
Podemos agarrar un repo BDS (pedir permiso para esto), yo estoy mirando people-hub que tiene varios módulos.
1. Controller - maneja rutas
   El persons.controller.ts tiene varios get.
2. Provider - provee
3. Module - organiza
   además de los imports/exports/controllers/providers, podría tener
   configuraciones (p.ej. de middleware) específicas para el módulo.

Receta - paso 1
Relación entre módulos: el SignUpRequestModule importa al PersonsModule.

Receta - paso 2
Ver en el app.module que están todos.

Receta - paso 3
Ver la inyección del servicio en PersonsController.

Bueno, ahora vamos a armar uno de cero.

(pasamos a "Empezamos a armar una app")
Para crear el proyecto y correrlo, eso lo saben mejor que yo (que todavía no me sé cómo hacer hot reload), y si no está en la doc.

Vamos con un endpoint. 
Pueden arrancar haciendo que devuelva algo fijo, para tener el circo armado.

Listo, ahora alcanza con acomodar algo del código que habíamos hecho en el ejercicio de async. Vamos con lo mínimo, una consulta sola.

Repasamos la necesidad de async/await, y los tipos.

Objetivo 1 entonces: un endpoint que busque info de RESTCountries.
En el servicio: que tome 
    export interface CountryInfo {
        countryCode: string,
        countryIso2Code: string,
        countryNames: { es: string, en: string },
        population: number,
        currency: {code: string, name: string, symbol: string},
        internetDomain: string
        neighborCountryCodes: string[],
    }
En el controller: que exponga
    export interface CountryInfoDTO {
        code: string,
        name: string,
        population: number,
        internetDomain: string
    }

Insistir mucho en que no pongan any en ningún lado, y que verifiquen que está chequeando, o sea, que si mandan datos de menos en el provider, o en lo que devuelve el controller, salte en el VSCode.

Ah, y usen lodash.pick con el tipado, es zarpado.


Bien, lo tenemos andando. 
Ahora agreguemos los datos de COVID.
(vamos a "Combinar datos de distintas fuentes")
... la info está en la página, tal vez convenga contarla en un orden distinto.

Tenemos dos tareas nuevas: resolver la consulta de datos COVID, y juntar todo en la respuesta del controller.

Antes que nada, creo que conviene aclarar lo de los códigos. 
Primero, que se entienda el problema, y que es algo que puede pasar cuando se interactúa con otros sistemas.
Aunque suene duro, les pido que repitan la consulta para obtener el Iso2Code. Por tres razones
1. creo que es más prolijo que en una aplicación, el id de una entidad que se expone sea coherente, o sea que no dependa de a qué servicio se llame. Los id de países que ponemos como parte de los URL, claramente se están exponiendo. 
2. que el servicio que obtiene el iso2Code a partir del iso3Code sea el mismo que se consulta para obtener los datos del país, es incidental.
3. nos va a servir para establecer una cache en el CovidDataService.

Para ser mínimamente prolijos, pongamos la consulta COVID en un método aparte, que va a estar en un provider. Y de ahí plantear los tres casos: 
- otro método en el mismo provider
- otro provider en el mismo módulo
- otro módulo

Ahora, dada la decisión de que el covid service se encarga de traducir de iso3Code a iso2Code, las consultas a los providers son independientes. No dejen de usar Promise.all.

Para la integración ¿qué pasa si la hacemos en el controller? Prueben. 

Yo diría, estén un rato probando distintas opciones.
Si definen dos módulos, tal vez lo que dice al final del forward ref les puede servir.

En algún momento, plantear/repasar qué pasa si el COVID service no da respuesta. Esta es otra faceta común que aparece cuando integramos datos: 
La primera pregunta es ¿qué hacemos, tiramos un 500? En este caso decidamos que no, que simplemente no incluimos el atributo con la info COVID en la respuesta.

Mirar lo que dice de incluir undefined como posible respuesta en el tipo.
Si no están usando strict, mostarlo yo que sí me puse strict.

    

Después manejo de errores.
Sobre esto probar
- ExceptionFilter que no hice
- en particular, 
  - si puede haber varios ExceptionFilter que apliquen, p.ej. uno global y otro para un controller. Si son de distinto ámbito (uno local, uno global) cuál se ejecuta primero.
  - si un ExceptionFilter puede no tocar el response, p.ej. sólo loguear, y que le lleguen request y response igualitos al siguiente ExceptionFilter. 
En la página va a contar
- si el país es CHN entonces forbidden
- 
Ejercicios sobre esto:

- que si la población es < 100000 entonces tire un error de "país insignificante"
- 


Podemos arrancar por planear los endpoints.

Cosas para mostrar
- agregar un atributo a la interface y ver cómo marca dónde falta
- cambiar la ruta en @Controller y ver cómo cambian todos los endpoints
- módulo que sólo tiene provider, y los exporta
- circular reference entre módulos
- magia del tipo de _.pick, eso me gustaría entenderlo mejor
- ir pensando en cache ¿no? al menos para los countryCodes
  - ¿cómo hacer para no buscar siempre para traducir de iso3code a iso2code?
- armar un proxy de axios que muestre las URL llamadas
- entender la sintaxis (await axios.get(url)).data
- la magia de cómo tipa el resultado de Promise.all en CovidDataService.getRecords
  - hay que ayudarlo en CountryDataController.getLongSummary, por qué
- el find en en CovidDataService.getRecords, uf, puede ser undefined
  cómo hago que pase strict: casteo (hasta que veamos manejo de errores)


----------------------------------------------
con qué seguir
- endpoint que falta de countries: :countryCode/neighbors
- definir qué endpoints vamos a seguir en clase, y qué se les deja para hacer
- implementar endpoints de fechas
- ver cómo se sigue, creo que lo siguiente sería meter
  - manejo de errores con exception handling
  - validación del formato de la fecha con interceptor
  - transformación de la fecha con un pipe
  - agregado del saludo también con middleware
  y después
  - refinar definición de qué hacemos en clase y qué es ejercicio
  - armar script
  - armar páginas